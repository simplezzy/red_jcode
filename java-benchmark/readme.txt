问题：
动态类型语言在Java7之前和之后分别是如何在JVM上运行的？
lambda表达式是如何实现的？
新一代垃圾收集器G1有哪些优势？
永久代为什么要被移除？元空间有什么不同吗？



一、指令集新成员：invokedynamic
    JVM被设计出来之后第一次改变指令集，引入这条新指令说明原来实现方法调用的指令有一定的缺陷。
      在Java7之前，JVM中包含了4条方法调用指令，分别是invokestatic、invokespecial、invokevirtual和invokeinterface，
    它们分别对应静态方法调用、构造方法/父类方法/私有方法调用、普通的类方法调用、接口方法调用四种场景
      在Constant Pool(常量池)中被定义为是Methodref( 方法引用),Methodref参数完整定义了一个方法，包括其所在的类、方法名、参数的类型
      java7引入了invokedynamic在JVM层面支持方法调用的动态化,编译时不再需要确定方法引用，而是由invokedynamic指令在运行时调用bootstrap方法在运行时决定方法的定义
      动态类型语言和静态类型语言
      区别在于变量类型是静态和动态,在运行时才确定变量类型的就属于动态类型语言，而在编译时就确定语言类型的属于静态类型语言

      Java、Scala是静态类型语言的代表，Groovy和JRuby是动态类型语言的代表
      java7之前是通过动态语言自己实现CallSite的方式在编辑器层面插入动态方法调用的逻辑。
      应用场景：
        场景1：更好地支持动态类型语言
                invokedynamic指令带来的变化:
                 1. Java API层面，引入CallSite, MethodHandle，将整个方法动态调用的过程标准化
                 2. JVM层面，通过invokedynamic指令简化动态代码调用的字节码
        场景2：实现lambda表达式
             Java8之前，我们也可以利用匿名类来实现类似于lambda表达式的效果
             lambda函数在底层并不是通过匿名类来实现的，匿名类会为每一个lambda表达式生成一个.class文件，这个从实现上来看不够优雅，性能上也会带来问题。
             而利用lambda就可以利用invokedynamic指令的动态调用特性实现lambda表达式的调用。

二、新的垃圾收集器: G1
   JDK 1.7 Update 14开始还引入了一个新的垃圾收集器G1，在此之前，互联网领域很多采用ParNew+CMS（Concurrent mark Sweep）的垃圾收集器组合进行分代垃圾回收。
   在平常工作中，我们最害怕的是出现Full GC，Full GC主要会进行老年代的垃圾回收，主流的老年代垃圾回收器CMS虽然设计目标是获得最短的回收停顿时间，但是仍然会导致一定时间的停服务(Stop The World)，所以会影响到服务的正常响应
   G1的工作机制
     G1是一款是以替换CMS为目标并且面向服务端应用的垃圾收集器，它的本质思想是化整为零。
   如果每次垃圾回收可以选择堆空间的一部分进行回收，那么停顿时间就可以被控制在合理的范围内。
      G1中依然是分代回收的概念，但是每一代的空间不再是简单地连续分配，他们被分散成多个大小相等的存储块，每个块都可以进行独立的垃圾回收，他们被称作Region。因为可以独立进行垃圾回收，那就有能力将一次很长的GC分解成多个短GC，通过调整每一次需要回收的Region数量来控制停顿时间的长短
      如何选择需要回收的Region呢？G1采用的是回收价值优先策略，能回收的空间越大，所需时间越短，就会获得较高的优先级而先被回收掉。
      难度可想而知。其实这也不是G1新引入的问题，G1和其它收集器一样都采用了Remembered Set（简称RSet）来避免全堆扫描，本质上就是一种空间换时间算法
      G1的优势在于：
         将垃圾回收化整为零，减少对用户服务的影响  分区Region Remembered Set（简称RSet）来避免全堆扫描，本质上就是一种空间换时间算法
         垃圾回收时间可配置   G1可以建立停顿预测模型。通过参数-XX:MaxGCPauseMillis指定一个收集过程的目标停顿时间
         避免内存碎片   采用“标记整理”算法取代了CMS的“标记清除”算法

三、 永久代被逐步移除，引入元空间Metaspace
    JDK8之前，堆被分为新生代、老年代; 除了堆之外，JVM中还有永久代，
    永久代中存放类的元数据(包括类的层级信息、方法数据和方法信息)、类的静态变 量、运行时常量池(包括字符串字面量、符号引用)等。
    其中，类的元数据和静态变量会在类被加载时被分配，类被卸载时被回收；而字符串字面量是在GC的时候就可能被回收。

    在HotSpot JVM中，永久代中用于存放类和方法的元数据以及常量池，在Java中对应能通过反射获取到的数据，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。

    永久代有哪些问题？
     1. JVM家族融合趋势，有些JVM没有永久代的设计，JRockit没有永久代，促进HotSpot JVM与JRockit VM的融合。
     2. 很难确定永久代需要的空间大小，如果设置不合理，会导致OOM。而且永久代的垃圾回收和老年代是绑定的，一旦其中一个占满，就会一起进行GC。
     3. 增加了GC实现的复杂度，对永久代中的元数据需要特殊处理
    解决：
     1. JDK7中，字符串字面量和类的静态变量首先被从永久代被移出到Java堆中;避免因为字符串字面量大量存储到字符串常量池中而导致的永久代内存溢出。
        永久代最终被移除，方法区移至Metaspace，字符串常量移至Java Heap。
     2. JDK8中，JVM彻底移除了永久代，同时引入元空间(Metaspace)来管理原来的元数据，这些元数据被分配到本地内存中进行管理。元空间默认上限是本地内存大小，所以降低了元空间OOM的可能性。
        因为默认不对元空间大小做限制，所以发生在元空间的内存泄露可能会耗尽内存，所以仍然需要通过监控来避免这种情况的发生。

     JDK 8开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。

     优点： OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，解决了空间不足的问题
         -XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小

     垃圾回收 如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。
             根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）

     新增参数
       -XX:MetaspaceSize是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。
       -XX:MaxMetaspaceSize是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。
       -XX:MinMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。
       -XX:MaxMetaspaceFreeRatio表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。

     监控与调优. VisualVM, jstat, jstack可以监测元空间的动态

   https://github.com/java8/Java8InAction.git